- Structured Query Language
- Developed based on the [ANSI SQL Standard](https://www.itl.nist.gov/div897/ctg/dm/sql_info.html). 
    - However, there are a lot of different vendor specific implementations available.

> [!quote]- SQL Architecture (Diagram)
> ![SQL Architecture](assets/images/sql.architecture.jpg) 
> **Source**: TutorialsPoint

## Data Types

- Each column must have a data type which restricts the type of data that can be assigned to it.
- **Categories**:
    - **Character**
        - `CHAR(n)` (Fixed-length)
        - `VARCHAR(n)` (Variable-length)
        - `TEXT` (for large amounts of text data)
    - **Numeric**
        - `DECIMAL`
        - `INT`, `SMALLINT`, `BIGINT`
        - `FLOAT`
    - **Temporal**
        - `DATE`
        - `TIME`
        - `TIMESTAMP`
    - **Binary Data** (MySQL)
        - `BINARY(n)` (Fixed-length)
        - `VARBINARY(n)` (Variable-length)

```sql
CREATE TABLE Employee (
    EmployeeID INT,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    Gender CHAR(1),
    DateOfBirth DATE,
    Salary DECIMAL(10, 2),
    IsManager BOOLEAN,
    DepartmentID INT,
    JoinDate TIMESTAMP
);
```

## Operators

- Arithmetic Operators: `+`, `-`, `*`, `/`
- Comparison Operators: `=`, `!=`, `<`, `>`
- Logical Operators: `AND`, `OR`, `NOT`
- Set Operators: `UNION`, `INTERSECT`, `EXCEPT`

## Constraints

- Enforce data integrity and maintain consistency within a relational database.

- `NOT NULL`
    - Ensures that a column's value is not null.
- `UNIQUE`
    - Ensures that a column's value is unique in the table.
- `PRIMARY KEY`
    - Combines `UNIQUE` and `NOT NULL`.
    - Uniquely identifies each row.
    - Must contain unique, non-NULL values
        - UNIQUE and NOT NULL implicitly.
    - A table can only have one primary key composed of single or multiple fields (*composite key*).
    - Generally created while the database and table are created, but can also be created after a table is created.
    - There are 3 types of Primary Keys:
        - **Surrogate Key**: Autogenerated by the database.
        - **Natural Key**: Naturally generated by the outside world.
        - **Composite Key**: The combination of 2 or more columns generates a unique identifier which you can utilize as the primary key.
- `FOREIGN KEY`
    - aka *referencing key*
    - Links to a row in another table.
    - A column or combination of columns whose values match a primary key in a different table.
    - Prevents the destruction of those links.
- `DEFAULT`
    - Specifies a value for a column, if one is not given.
    - Must be a literal constant.
- `CHECK`
    - Ensures the value of a column satisfies a specific condition.
    - Example: `size DECIMAL CHECK (size > 0 AND size <= 100)`

- It's possible to use a combination of constraints on each column of a table, but in some cases it might lead to redundancy (e.g. `NOT NULL DEFAULT`) and/or conflicting requirements (e.g. `DEFAULT CHECK`).
- To generate an auto-incrementing number column:
    - **PostgreSQL** - `SERIAL`
    - **MySQL** - `AUTO_INCREMENT`
    - **SQLite** - `AUTOINCREMENT`

```sql
CREATE TABLE table_name (
    variable_name variable_datatype AUTO_INCREMENT,
    -- Other columns...
);

CREATE TABLE table_name (
    variable_name variable_datatype PRIMARY KEY AUTOINCREMENT,
    -- Other columns...
);

CREATE TABLE table_name (
    variable_name SERIAL PRIMARY KEY, -- Type and Value implicitly created
    -- Other columns...
);
```

- Modifying the `DEFAULT` constraint of a column:

```sql
-- Add a `DEFAULT` constraint to an existing column of a table
ALTER TABLE table_name ALTER col_name SET DEFAULT default_value;

-- Remove a `DEFAULT` constraint from an existing column of a table.
ALTER TABLE table_name ALTER col_name DROP DEFAULT;
```

### Keys

```sql
CREATE TABLE [IF NOT EXISTS] Users(
    ID    INT           NOT NULL,
    NAME  VARCHAR(20)   NOT NULL,
    AGE   INT           NOT NULL,
    PRIMARY KEY(ID)
);

CREATE TABLE Orders(
    OID      INT        NOT NULL,
    DATE     DATETIME,
    AMOUNT   INT,
    USER_ID  INT,
    FOREIGN KEY (USER_ID) references Users(ID),
    -- or USER_ID INT references Users(ID),
    PRIMARY KEY(OID)
);
```

```mysql
-- Add a Primary Key to an existing table
ALTER TABLE Users ADD PRIMARY KEY (ID);

-- Add a Foreign Key to an existing table
ALTER TABLE Orders
   ADD FOREIGN KEY (USER_ID) REFERENCES Users(ID);
```

- `CASCADE` 
    - Used to simultaneously delete or update data from both the child and parent tables.
    - Allows us to perform operations in a single command without violating the referential integrity.
    - Used in conjunction while writing a query with `ON DELETE` or `ON UPDATE`.

```mysql
CREATE TABLE Orders(
    OID      INT        NOT NULL,
    DATE     DATETIME,
    AMOUNT   INT,
    UID  INT,
    PRIMARY KEY(OID),
    FOREIGN KEY (UID) references Users(ID) ON DELETE CASCADE ON UPDATE CASCADE
);
```

- A `UNIQUE` key allows for `NULL` column values for records.
    - For databases that allow `NULL` values for a `UNIQUE` field, the `UNIQUE` constraint applies only to the non-null values. 
        - i.e. Multiple `NULL` entries for a `UNIQUE` field won't be considered as duplicates.

```sql
CREATE TABLE users (
    user_id INT UNIQUE,
    first_name VARCHAR(255)
);

INSERT INTO students (studentId, firstName, lastName) VALUES
    (1, 'John'),
    (2, 'Jane'),
    (NULL, 'Alice'),  -- Valid
    (NULL, 'Bob');    -- Valid
```

- A candidate key is a field or combination of fields that uniquely identifies each row in a table.
- All candidate keys that are not primary keys are *secondary* or *alternate* keys.
    - Not related to foreign keys.
    - Help ensure data integrity.
    - Used for indexing.

```sql
CREATE TABLE Book (
    BookID INT PRIMARY KEY,   -- Primary Key
    ISBN VARCHAR(20) UNIQUE,  -- Secondary Key
    Name VARCHAR(100)
);
```

## Sublanguages

### DDL

- Data Definition Language 
- Defines data structure

- **`CREATE`**
    - Used to create objects on the server.
    - Can be used to create:
        - Database
        - User
        - Table
        - Index
        - Trigger
        - Function
        - Stored Procedure
        - View
    - In certain RDBMS with transactional DDL (e.g. Postgres, SQLite), rollbacks are allowed.

```mysql
CREATE DATABASE [IF NOT EXISTS] my_db;

-- Required in MySQL
USE my_db; 

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] my_table (
    col_name data_type constraints,
    -- ...
);
```

- **`DROP`**
    - Used to remove objects from the server. 
    - Can't be rolled back.
    - Any object created using `CREATE` can be dropped using `DROP`.
    - It's not allowed to drop a table referenced by foreign key constraint.
        - Objects related to the table like views, procedures needs to be explicitly dropped.

```sqlite
-- Completely remove a table from database.
DROP [TABLE] table_name;
```

- **`ALTER`**
    - Used to change some characteristics of an object, i.e. to add, drop, or modify some option on the object.
    - Commonly used to change table characteristics, like:
        - Add/Drop columns
        - Add/Drop constraints
        - Modify column data types
        - Modify column constraints

```mysql
-- Alter the table.
ALTER TABLE table_name;

-- Rename a table.
ALTER TABLE old_table_name 
RENAME TO new_table_name;

-- Add a column to a table.
ALTER TABLE table_name
ADD column_name INT;

-- MySQL - Modify a column.
ALTER TABLE table_name
MODIFY COLUMN column_name TEXT;

-- Drop a column from a table.
ALTER TABLE table_name
DROP COLUMN column_name;
```

- **`TRUNCATE`**
    - Used to remove all data from a table along with all space allocated for the records.
        - Also deallocates memory for removed objects.
    - Can't be rolled back.
    - Conditions aren't allowed.
    - Unlike `DROP` truncate will preserve the structure of the table.

```sql
-- Remove all the data and not the table itself.
TRUNCATE [TABLE] table_name;
```

- **`RENAME`**
    - Used to rename objects.
    - Availability and syntax of `RENAME` varies between different DBMS.

```mysql
RENAME TABLE old_name TO new_name [, old_name2 TO new_name2] -- ...
```

- **`COMMENT`**
    - Typically used to add comments or descriptions to database objects like tables, columns, or views. 
    - Comments are not used by the database itself but can be helpful for documentation purposes or for providing additional information about the structure of the database. 
        - Could also be written using `--` for single line and `/* */` for multi-line comments.

### DML

- Data Manipulation Language
- Used to manage data within database objects.

- **`INSERT`**
    - Used to insert records into a table.

```sql
INSERT INTO table_name (column1,...columnN)
VALUES (value1,...valueN)[, (valueA,...valueZ)];
```

- **`UPDATE`**
    - Used to modify whole records or parts of records in a database table.
    - Can modify multiple records if conditions don't provide unique results.

```sql
UPDATE table_name 
SET col_name = value[, col2_name = value2, ...]
[WHERE condition];
```

- **`DELETE`**
    - Used to remove data from a database table.

```sql
DELETE FROM table_name 
[WHERE condition];
```

### DQL

- Data Query Language 
- Search, filter, group, aggregate stored data

- **`SELECT`**

```mysql
SELECT <projection> 
FROM <table_name> 
<filter> 
<grouping> 
<ordering> 
<offset>

-- OR

SELECT [ALL | DISTINCT]
    select_expr [, select_expr] ...
    [into_option]
    [FROM table_ref]
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}]
    [HAVING having_condition]
    [ORDER BY {col_name | expr | position}]
        [ASC | DESC]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}];
```

```sql
SELECT column1, column2, columnN FROM table_name;

-- Aliases
SELECT column1 as col1, column2 as col2, columnN FROM table_name;

SELECT * FROM table_name;

SELECT *           -- SELECT Users.age
FROM table_name    -- FROM Users
WHERE [condition]; -- WHERE name = 'John'
```

> [!note]
> The `WHERE` clause is used in `SELECT`, `INSERT` and `UPDATE` statements

- **Filtering using `WHERE`**
    - **`IN`**
        - True if the operand is included in a list of expressions.
        - e.g., `WHERE id IN (23, 45, 67)`
    - **`NOT`**
        - Meaning: Reverses the value of any boolean expression.
        - e.g., `WHERE NOT (id=100)`
    - **`LIKE`**
        - Meaning: True if the operand matches a pattern (`%` for zero or more characters & `_` to match any single character).
        - e.g., `WHERE type LIKE 'a%'` (starts with 'a'), `WHERE type LIKE '___'` (exactly 3 characters long)            
    - **`BETWEEN`**
        - Meaning: True if the operand falls within a range.
        - e.g., `WHERE price BETWEEN 1.5 and 2.5`, `WHERE name BETWEEN 'm' AND 'p'`

- **Grouping using `GROUP BY`**
    - Group rows that have the same values into summary rows.
    - Often mandatory to be used with aggregate functions like `count`, `max` and `min`.
    - Grouping is done based on the similarity of the row's attribute values.
    - Always used before the `ORDER BY` clause in `SELECT`.
    - `HAVING` can be used to filter out groups that meet a certain condition.

```mysql
SELECT type, AVG(price) FROM cars GROUP BY type;
```

- **Ordering using `ORDER BY`**
    - Ensures presentation of columns.
    - Output is sorted based on the column's values.
    - Always used after the `GROUP BY` clause in `SELECT`.

```sql
SELECT columns FROM table_name ORDER BY col1 [, col2, ...] [ASC | DESC];

SELECT name, price FROM cars ORDER BY name ASC;
```

- **Offset using `LIMIT` and `OFFSET`**
    - `LIMIT` restricts the number of records returned from a `SELECT` statement.
    - `OFFSET` specifies from which record position to start counting from.
        - Often used in conjunction with the `LIMIT` clause.
        - Some SQL implementations use the `SKIP` keyword instead of `OFFSET`.

```sql
-- Limit
SELECT name, price FROM cars ORDER BY name ASC LIMIT 10;

-- Offset
SELECT name, price, type FROM produce ORDER BY name ASC LIMIT 5 OFFSET 5;
```

- **`JOIN`**
    - Used to combine records from two or more tables in a database. 
    - A means for combining fields from two tables by using values common to each.
    - Different Types of Joins
        - INNER JOIN
        - OUTER JOIN
            - LEFT JOIN
            - RIGHT JOIN
            - FULL JOIN

> [!quote]- SQL Joins
 > ![[SQL Joins (Datacamp).pdf]]
 > 
 > **Source**: [Datacamp](https://datacamp.com/)

```sql
-- Implicit Join without using 'JOIN' ()
SELECT Users.ID, Users.Name, Orders.Amount, Orders.OrderDate
FROM Users, Orders
ON Users.ID = Orders.UserID;

-- Inner Join (Explicit Join - Recommended)
SELECT Users.ID, Users.Name, Orders.Amount, Orders.OrderDate
FROM Users 
INNER JOIN Orders
ON Users.ID = Orders.UserID;
```

> [!quote]- SQL Joins Diagram
 > ![SQL Joins Diagram](assets/images/sql.joins-diagram.png)
 > 
 > **Source**: [DbVisualizer](https://dbvis.com/)

- **INNER JOIN**
    - Returns records that have matching values in both tables.
    - Compares each row of the first table with each row of the second table.
        - If the join condition is true, it creates a new row combining columns from both tables.
    - **Use cases**:
        - Finding related records across tables.
        - Filtering out records that don't have corresponding entries in both tables.

```sqlite
SELECT e.EmployeeName, d.DepartmentName
FROM Employees e
INNER JOIN Departments d 
ON e.DepartmentID = d.DepartmentID;
```

- **LEFT JOIN (LEFT OUTER JOIN)**
    - Returns all records from the left table and matched records from the right table. 
    - If there's no match, the result is NULL on the right side.
    - Includes all rows from the left table.
        - For each row in the left table, it looks for matching rows in the right table.
        - If a match is found, it combines the data; if not, it fills with NULL for right table columns.
    - **Use cases**:
        - Finding all records from one table, regardless of whether they have corresponding records in another table.
        - Identifying records in one table that don't have matches in another (by filtering for NULL values in the joined columns).

```sqlite
SELECT e.EmployeeName, d.DepartmentName
FROM Employees e
LEFT JOIN Departments d 
ON e.DepartmentID = d.DepartmentID;
```

- **RIGHT JOIN (RIGHT OUTER JOIN)**
    - Similar to LEFT JOIN but returns all records from the right table and matched records from the left.
    - Includes all rows from the right table.
        - For each row in the right table, it looks for matching rows in the left table.
        - If a match is found, it combines the data; if not, it fills with NULL for left table columns.
    - **Use cases**:
        - Similar to LEFT JOIN, but when you want to prioritize the right table.
        - Often, developers prefer using LEFT JOIN and switching table order instead of using RIGHT JOIN for consistency.

```sqlite
SELECT e.EmployeeName, d.DepartmentName
FROM Employees e
RIGHT JOIN Departments d 
ON e.DepartmentID = d.DepartmentID;
```

- **FULL JOIN (FULL OUTER JOIN)**
    - Returns all records when there's a match in either the left or right table.
    - Combines the results of both LEFT and RIGHT joins.
        - Returns all rows from both tables, with NULL values where there's no match.
    - **Use cases**:
        - Getting a complete view of data from two tables, including unmatched records from both sides.
        - Identifying records that exist in one table but not in the other.

```sqlite
SELECT e.EmployeeName, d.DepartmentName
FROM Employees e
FULL JOIN Departments d 
ON e.DepartmentID = d.DepartmentID;
```

- **CROSS JOIN / CARTESIAN JOIN**
    - Used to return all possible row combinations from each table.
    - If no condition is provided, the result set is obtained by multiplying each row of the first table with all rows in the second table.
    - Common use cases:
        - Creating a comprehensive dataset for testing
        - Finding missing relationships

```sqlite
SELECT *  
FROM table_1
CROSS JOIN table_2;
```

- **SELF JOIN**
    - Used to intersect or join a table in the database to itself.

```sqlite
SELECT table_1.col_1 AS col_a, table_2.col_2 AS col_b
FROM my_table table_1
JOIN my_table table_2 ON table_1.col_3 = table_2.col_4;

-- or

SELECT table_1.col_1 AS col_a, table_2.col_2 AS col_b
FROM my_table table_1, my_table table_2
WHERE table_1.col_3 = table_2.col_4;
```

- **Set Operations**
    - Used to combine the result of two queries.
    - To perform set operations,
        - The order and number of columns must be the same.
        - Data types must be compatible.
    
    - `UNION`
        - Merges result sets of multiple `SELECT` statements into a single result set, removing duplicates.
        - `UNION ALL` doesn't remove duplicate rows.
        - `SELECT * FROM table_a UNION SELECT * FROM table_b;`
    - `INTERSECT`
        - Retrieves the common rows that appear in the result sets of two `SELECT` statements.
        - Unsupported by MySQL
        - `SELECT * FROM table_a INTERSECT SELECT * FROM table_b;`
    - `EXCEPT`
        - Retrieves rows present in the result set of the first `SELECT` statement but not in the second `SELECT` statement.
        - `MINUS` is found in some databases, and is functionally equivalent to `EXCEPT`.
        - `SELECT * FROM table_a EXCEPT SELECT * FROM table_b;`

### DCL

- Data Control Language 
- Used for access control to grant or revoke access permissions to database objects
- `GRANT`, `REVOKE`

```postgresql
-- Revoke a specific privilege from a role
REVOKE SELECT ON table_name FROM role_name;

-- Revoke all privileges on a table from a user or role
REVOKE ALL PRIVILEGES ON table_name FROM user_or_role;

-- Revoke a privilege from multiple roles at once
REVOKE SELECT ON table_name FROM role1, role2, role3;

-- Revoke a privilege from PUBLIC (all roles)
REVOKE SELECT ON table_name FROM PUBLIC;

-- Revoke EXECUTE privilege on a function
REVOKE EXECUTE ON FUNCTION function_name() FROM role_name;

-- Revoke privileges on all tables in a schema
REVOKE SELECT ON ALL TABLES IN SCHEMA schema_name FROM role_name;

-- Revoke a role from a user
REVOKE role_name FROM user_name;
```

### TCL

- Transaction Control Language 
- Defines concurrent operation boundaries
- `SAVEPOINT`, `ROLLBACK`, `COMMIT`

## Example

```postgresql
-- Create the database
CREATE DATABASE ecommerce;

-- Create roles
CREATE ROLE admin_role;
CREATE ROLE customer_role;

-- Create users and assign roles
CREATE USER admin_user WITH PASSWORD 'admin_password';
CREATE USER customer_user WITH PASSWORD 'customer_password';

GRANT admin_role TO admin_user;
GRANT customer_role TO customer_user;

-- Grant privileges
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO admin_role;

GRANT SELECT, INSERT, UPDATE ON customers TO customer_role;
GRANT SELECT ON products TO customer_role;
GRANT SELECT, INSERT ON orders TO customer_role;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO customer_role;

-- Insert sample data
INSERT INTO products (name, description, price, stock_quantity) 
VALUES
    ('Laptop', 'High-performance laptop', 999.99, 50),
    ('Smartphone', 'Latest model smartphone', 599.99, 100),
    ('Headphones', 'Noise-cancelling headphones', 199.99, 200);

-- Create a stored procedure for customer registration
CREATE OR REPLACE FUNCTION register_customer(
    p_username VARCHAR(50),
    p_email VARCHAR(100),
    p_password VARCHAR(255)
) RETURNS void AS $$
BEGIN
    INSERT INTO customers (username, email, password_hash)
    VALUES (p_username, p_email, p_password);
END;
$$
 LANGUAGE plpgsql;

-- Grant execute permission on the stored procedure
GRANT EXECUTE ON FUNCTION register_customer(VARCHAR, VARCHAR, VARCHAR) TO customer_role;

-- In Application Code

-- Register a new customer (as customer_user)
SET ROLE customer_user;
SELECT register_customer('john_doe', 'john@example.com', 'hashed_password_here');

-- Place an order (as customer_user)
INSERT INTO orders (customer_id, total_amount) 
VALUES ((
    SELECT customer_id 
    FROM customers 
    WHERE username = 'john_doe'
), 1599.98);

-- Reset role
RESET ROLE;
```

## Aggregate Functions

- `COUNT()` - Returns the number of rows in a set.

```postgresql
SELECT COUNT(*) AS total_employees FROM employees;
```

- `SUM()` - Returns the total sum of a numeric column.

```postgresql
SELECT SUM(salary) AS total_salary FROM employees;
```

- `AVG()` - Returns the average value of a numeric column.

```postgresql
SELECT AVG(salary) AS average_salary FROM employees;
```

- `MIN()` - Returns the smallest value in a set.

```postgresql
SELECT MIN(salary) AS lowest_salary FROM employees;
```

- `MAX()` - Returns the largest value in a set.

```postgresql
SELECT MAX(salary) AS highest_salary FROM employees;
```

## Schemas

- A collection of database objects that define the structure of the database.
- Acts as a namespace that helps organize and segregate data.
- **Use Cases**
    - *Logical Organization* - Grouping related tables and other objects together.
    - *Access Control* - Managing permissions and security at a granular level.
    - *Data Integrity* - Enforcing rules and relationships between tables.
- **Components**
    - Tables
    - Views
    - Stored Procedures
    - Functions
    - Indexes

```postgresql
CREATE SCHEMA bookstore AUTHORIZATION db_owner;
```

```postgresql
CREATE SCHEMA IF NOT EXISTS Products;
CREATE SCHEMA IF NOT EXISTS Orders;

CREATE TABLE IF NOT EXISTS Products.Items (
    ItemID SERIAL PRIMARY KEY,
    ItemName VARCHAR(100) NOT NULL,
    Price DECIMAL(10, 2) NOT NULL,
    StockQuantity INT NOT NULL
);

CREATE TABLE IF NOT EXISTS Orders.OrderDetails (
    OrderID SERIAL PRIMARY KEY,
    ItemID INT NOT NULL,
    Quantity INT NOT NULL,
    OrderDate DATE NOT NULL,
    FOREIGN KEY (ItemID) REFERENCES Products.Items(ItemID)
);

SELECT * FROM Products.Items;
SELECT * FROM Orders.OrderDetails;
```

```sql
-- Multiple Objects in One Statement
CREATE SCHEMA schema_name
    CREATE TABLE table_name1 (...),
    CREATE TABLE table_name2 (...),
    CREATE VIEW view_name AS SELECT ...;
```

> [!note]
> - The `public` schema in Postgres is a default schema that is created automatically when a new database is initialized. 
>     - It serves as a shared namespace for database objects, allowing users to create and access tables, views, functions, and other objects without needing to specify a schema name.
> ```sql
> CREATE TABLE my_table (id SERIAL PRIMARY KEY);
> -- is equivalent to:
> CREATE TABLE public.my_table (id SERIAL PRIMARY KEY);
> ```

## Indexing

- An index is a database object that provides a fast and efficient way to look up and retrieve data from a table.
- Improves the performance of `SELECT` queries by reducing the amount of data that needs to be scanned.

```postgresql
-- Create a Non-Clustered Index on 'Users'
CREATE INDEX idx_UserID ON Users(user_id);

-- Create a Clustered Index on 'Accounts'
CREATE INDEX idx_AccountID ON Accounts(account_id);

CLUSTER Accounts USING idx_AccountID;
```

> [!important]
> The order of operations is crucial.

## Transactions

- Ensure that a series of database operations are treated as a single unit of work, maintaining data integrity and [[Database Consistency|consistency]], even in the face of system failures or concurrent access.

```sqlite
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

COMMIT;
-- or ROLLBACK; if there's an error
```

```sqlite
-- With Error Handling
BEGIN TRANSACTION;

BEGIN TRY
    UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
    COMMIT;
END TRY
BEGIN CATCH
    ROLLBACK;
    -- Log error or handle it appropriately
END CATCH
```

## Views

- A virtual table based on the result of a `SELECT` query.
- Provide a way to represent the result of a query as if it were a table.
- Can be used to restrict access to specific columns or rows of a table. 
    - Users can be granted permission to access a view without granting direct access to the underlying table.
- Can also be used to save commonly used or complex queries by giving them a name.

```sqlite
CREATE OR REPLACE VIEW view_name AS
    SELECT column1, column2, ...
    FROM table_name
    WHERE condition;

SELECT * FROM view_name;
```

## Stored Procedures

- Precompiled collection of one or more SQL statements stored in the database.
- Can accept parameters, execute complex operations, and return results. 
- Help encapsulate business logic and improve performance by reducing the need to send multiple queries from an application to the database.

```postgresql
CREATE PROCEDURE my_procedure (param_1 datatype, param_2 datatype) AS
BEGIN
    -- SQL statements
END;

CALL my_procedure(arg_1, arg_2);
```

### Triggers

- A special type of stored procedure.
- Automatically runs SQL code in response to DML events.

```sqlite
CREATE OR REPLACE TRIGGER delete_user AFTER DELETE ON users
BEGIN
    -- Custom Logic
END;
```

## Functions

- Returns a single value or a table.
- Can be used in SQL statements like any other expression.

```postgresql
CREATE OR REPLACE FUNCTION function_name (para_1 datatype, param_2 datatype)
RETURNS datatype AS
BEGIN
    -- Function logic
    RETURN value;
END;

SELECT function_name(arg_1, arg_2) AS some_name;
```

## Subquery

- A query nested inside of a larger query. 
- Can occur in various subsections of a query:
    - `SELECT` clause (Inner Query)
        - Create temporary columns on the result set
            - The column created by an inner query has a value equal to the result of the query.
        - Can also be called `inner query` or `inner select` while the container query is called the `outer query` or `outer select`
        - The `inner query` executes before the `outer query`
    - `WHERE` clause (Nested Query)
        - Can return single or multiple rows
    - `FROM` clause (Inline View)
        - Create temporary tables
- Can be nested in a `SELECT`, `INSERT`, `UPDATE`, `DELETE`, or even inside of another subquery.
- Logical operators can be used to compare the results of the subquery
- While convenient, subqueries perform worse than joins.

```sql
CREATE TABLE IF NOT EXISTS students(
    id INT PRIMARY KEY,
    name VARCHAR(40) NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS evaluations (
    id INT PRIMARY KEY,
    studentId INT NOT NULL,
    evalName VARCHAR(10) NOT NULL,
    mark INT DEFAULT 0,
    FOREIGN KEY(studentId) REFERENCES students(id),
    CONSTRAINT mark_check CHECK(mark >= 0), CHECK(mark <= 100)
);

INSERT INTO students (id, name) 
VALUES (1, 'Steve'), (2, 'Jane'), (3, 'Casey');

INSERT INTO evals (id, studentId, evalName, mark) 
VALUES 
    (1, 1, 'quiz 1', 98),
    (2, 2, 'quiz 1', 80), 
    (3, 3, 'quiz 1', 95), 
    (4, 1, 'test 1', 72), 
    (5, 2, 'test 1', 100), 
    (6, 3, 'test 1', 68);

-- To find all students that scored higher than Jane (2) on 'quiz 1'

-- Nested Query
SELECT a.id, a.name, b.evalName, b.mark
FROM students a, evals b 
WHERE a.id = b.studentId AND b.evalName = 'quiz 1' AND b.mark > (
    SELECT mark 
    FROM evals 
    WHERE evalName = 'quiz 1' AND studentId = 2
);

-- Inline View (Temporary Tables)
SELECT a.name, b.evalName, b.mark 
FROM students a, (
    SELECT studentId, evalName, mark
    FROM evals 
    WHERE mark > 90
) b 
WHERE a.id = b.studentId;

-- Inline Query (Temporary Columns)
SELECT a.id, a.name, (
    SELECT AVG(mark) 
    FROM evals 
    WHERE studentId = a.id 
    GROUP BY studentId
) avg 
FROM students a;
```

## Quotes

### Single Quotes

-  Primarily used to enclose string literals. 
    - e.g., `SELECT * FROM users WHERE name = 'John';`
- If a single quote needs to be included within a string, it can be escaped by doubling it. 
    - e.g., `SELECT * FROM users WHERE name = 'O''Reilly';`
- Required by most SQL databases (like SQL Server, PostgreSQL, and Oracle) for string literals. 

### Double Quotes

- Generally used to denote identifiers, such as table or column names, particularly when these names include special characters or spaces. 
    - e.g., `SELECT "First Name" FROM "User Info";`
- The behavior of double quotes can differ across database systems. 
    - MySQL allows both single and double quotes for strings interchangeably, making it more flexible compared to others.
    - PostgreSQL uses double quotes strictly for identifiers and requires single quotes for string literals.

> [!note]
> It is generally recommended to reserve double quotes for identifiers to avoid confusion and ensure compatibility across different SQL dialects.

---
## Skill Gap

- Self Joins
- Full Text search
- Transactions
    - Isolation Levels
    - BEGIN
    - COMMIT
    - ROLLBACK
    - SAVEPOINT
- Postgres
    - [PostgreSQL](https://www.prisma.io/dataguide/postgresql)
    - `psql`
    - `hstore`
    - ENUMs
    - Caching (`pgBouncer`)
    - Architecture: https://www.youtube.com/watch?v=Q56kljmIN14
    - Playlist: https://www.youtube.com/playlist?list=PLQnljOFTspQWGrOqslniFlRcwxyY94cjj

---
## Further

### Learn 🧠

- [Intro to Databases with SQL (CS50)](https://cs50.harvard.edu/sql/2024/weeks/) ⭐

- [The SQLite Handbook (SQL Docs)](https://sqldocs.org/sqlite/introduction/) ⭐

- [Complete SQL and Databases Bootcamp (Udemy)](https://www.udemy.com/course/complete-sql-databases-bootcamp-zero-to-mastery/)

- [SQL Tutorial (freeCodeCamp)](https://youtube.com/watch?v=HXV3zeQKqGY)

### Roadmaps 🗺

- [PostgreSQL Roadmap](https://roadmap.sh/postgresql-dba)

### Videos 🎥

![SQL Joins Explained](https://www.youtube.com/watch?v=9yeOJ0ZMUYw)